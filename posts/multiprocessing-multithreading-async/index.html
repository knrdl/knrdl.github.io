<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=content-security-policy content="default-src 'none'; style-src 'self' 'unsafe-inline'; img-src 'self' https:; font-src 'self'; script-src 'unsafe-inline'"><link rel="shortcut icon" type=image/png href=/favicon.png><link rel=sitemap type=application/xml href=/sitemap.xml title=knrdlog><title>Multi-Processing, Multi-Threading, Async: What's the difference?</title><meta name=description content="notes to self"><meta property="og:title" content="Multi-Processing, Multi-Threading, Async: What's the difference?"><meta property="og:description" content="The problem In programming there is often a need to run things in parallel:
Execution time is optimized if tasks run in parallel A webserver needs to handle multiple requests simultaneously If the program sends an email, this should not block other operations &mldr; There are three different approaches for these requirements.
Multi Processing / Multi Programming gitlab&rsquo;, &lsquo;docker&rsquo;, &lsquo;devops This is the typical use-case for batch jobs:
convert a lot of images between formats compress files reproject a bunch of gis objects convert the slides of a presentation into the pdf-format and concat them afterwards A typical setup looks like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://knrdl.github.io/posts/multiprocessing-multithreading-async/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-03T21:24:55+02:00"><meta name=author content="knrdl"><link rel=stylesheet href=https://knrdl.github.io/styles.min.d0a5c24e5cf581dcf65611cb27dfd4799b0cbdc02e48197a144ef1eba4c2166d.css integrity="sha256-0KXCTlz1gdz2VhHLJ9/UeZsMvcAuSBl6FE7x66TCFm0="></head><body><header><div class=site-header><span><a href=https://knrdl.github.io/ class=site-title>knrdlog</a></span>
<span><nav class=right-menu><span class=menu-item><a href=/tags/>tags</a></span>
<span class=menu-item><a href=https://github.com/knrdl target=_blank rel="noopener noreferrer">github</a></span>
<span class=menu-item><a href=/index.xml>rss</a></span></nav></span></div><div class=separator>================================================================================================================================================================</div></header><main><article><div class=post-header><h1>Multi-Processing, Multi-Threading, Async: What's the difference?</h1><time datetime=2022-09-20 class=pubdate>2022-09-20</time>
<time datetime=2022-10-03 class=lastmod>[Updated 2022-10-03]</time>
<span class=tags></span></div><h2 id=the-problem class=paragraph-header>The problem <a href=#the-problem></a></h2><p>In programming there is often a need to run things in parallel:</p><ul><li>Execution time is optimized if tasks run in parallel</li><li>A webserver needs to handle multiple requests simultaneously</li><li>If the program sends an email, this should not block other operations</li><li>&mldr;</li></ul><p>There are three different approaches for these requirements.</p><h2 id=multi-processing--multi-programming class=paragraph-header>Multi Processing / Multi Programming <a href=#multi-processing--multi-programming></a></h2><p>gitlab&rsquo;, &lsquo;docker&rsquo;, &lsquo;devops
This is the typical use-case for batch jobs:</p><ul><li>convert a lot of images between formats</li><li>compress files</li><li>reproject a bunch of gis objects</li><li>convert the slides of a presentation into the pdf-format and concat them afterwards</li></ul><p>A typical setup looks like this:</p><ul><li>one <strong>manager</strong> process: coordinates the workers by distributing the tasks among them</li><li>one <strong>worker</strong> process per logical cpu core: performs the supplied task and gets the next one from the manager when finished</li></ul><p>To reduce overhead the manager might not supply single tasks to the workers, but small batches of tasks.</p><p>This concept is useful when there is no shared memory between the tasks, e.g. converting image #170 has no influence on the conversion of image #171 or #172. An implementation might use the process infrastructure as provided by the operating system.</p><h2 id=multi-threading class=paragraph-header>Multi Threading <a href=#multi-threading></a></h2><p>green threads</p><p>lock/release gil</p><h2 id=async-programming class=paragraph-header>Async Programming <a href=#async-programming></a></h2><p>go routines</p><p>rust tokio async executor</p><div class=comments><a href="https://github.com/knrdl/knrdl.github.io/issues/new?title=Multi-Processing%2C+Multi-Threading%2C+Async%3A+What%27s+the+difference%3F" target=_blank rel="noopener noreferrer"><img src=https://knrdl.github.io/github.png alt="Github logo" style=filter:invert(.7) width=17 height=17>
<span>Feedback</span></a></div></article></main><hr><footer>Licensed under <a href=https://creativecommons.org/publicdomain/zero/1.0/ target=_blank rel='noopener norefferer'>CC0 1.0</a> |
<a href=https://gohugo.io target=_blank rel='noopener norefferer'>Hugo</a> theme inspired by <a href=https://github.com/vamc19 target=_blank rel='noopener norefferer'>vamc19</a> |
Hosted by <a href=https://pages.github.com target=_blank rel='noopener norefferer'>Github</a> (<a href=https://github.com/site/privacy target=_blank rel='noopener norefferer'>Privacy Policy</a>)</footer></body></html>