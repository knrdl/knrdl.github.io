<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Content-Security-Policy content="default-src 'none'; style-src 'self' 'unsafe-inline'; img-src 'self' https:; font-src 'self'; script-src 'unsafe-inline'"><link rel="shortcut icon" type=image/png href=/favicon.png><link rel=sitemap type=application/xml href=/sitemap.xml title=knrdlog><title>Explaining Database Connection Pooling</title>
<meta name=description content="notes to self"><meta property="og:title" content="Explaining Database Connection Pooling"><meta property="og:description" content="the problem Connection Pooling is an often overlooked concept when it comes to databases. An inexperienced developer might implement an API backend like this:
HTTP Request comes in Open connection to the database Execute SQL command and read response Close connection to the database (also often forgotten) Send HTTP response Opening and closing a connection (step 2 & 4) produces load on the database server instance. Beside the number of parallel open connections is limited."><meta property="og:type" content="article"><meta property="og:url" content="https://knrdl.github.io/posts/db-connection-pooling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-04T22:02:17+02:00"><meta name=author content="knrdl"><link rel=stylesheet href=https://knrdl.github.io/styles.min.b1eb305989f01c7be31a7a19d4ab34ca470eddd06327253c7bcf3d1c5a41d28c.css integrity="sha256-seswWYnwHHvjGnoZ1Ks0ykcO3dBjJyU8e889HFpB0ow="></head><body><header><div class=site-header><span><a href=https://knrdl.github.io/ class=site-title>knrdlog</a>
</span><span><nav class=right-menu><span class=menu-item><a href=/tags/>tags</a></span>
<span class=menu-item><a href=https://github.com/knrdl target=_blank rel="noopener noreferrer">github</a></span>
<span class=menu-item><a href=/index.xml>rss</a></span></nav></span></div><div class=separator>================================================================================================================================================================</div></header><main><article><div class=post-header><h1>Explaining Database Connection Pooling</h1><time datetime=2022-10-04 class=pubdate>2022-10-04</time>
<span class=tags><a href=/tags/databases class=hashtag>databases</a>
<a href=/tags/postgres class=hashtag>postgres</a>
<a href=/tags/sql class=hashtag>sql</a></span></div><h2 id=the-problem class=paragraph-header>the problem <a href=#the-problem></a></h2><p>Connection Pooling is an often overlooked concept when it comes to databases. An inexperienced developer might implement an API backend like this:</p><ol><li>HTTP Request comes in</li><li>Open connection to the database</li><li>Execute SQL command and read response</li><li>Close connection to the database (also often forgotten)</li><li>Send HTTP response</li></ol><p>Opening and closing a connection (step 2 & 4) produces load on the database server instance. Beside the number of parallel open connections is limited. That way forgetting to close connections might even make the database unavailable in the long run. Connection pooling solves these issues by keeping a sufficient number of durable connections to the database open.</p><h2 id=the-metaphor class=paragraph-header>the metaphor <a href=#the-metaphor></a></h2><figure><img src=metaphor.png alt="metaphor visualization" style=max-height:375px></figure><p>Metaphor: Between Server and Database exists a tunnel, called network link. In the tunnel is a single track of rails, known as connection. As said, reusing the rails is easier than building new ones everytime. The track of rails carries a single wagon. The wagon transports a SQL command from the Server to the Database and returns the execution result (e.g. selected rows) back. If the wagon is in transit the railway is blocked. No other wagon can use the railway at the same time. Therefore, the tunnel doesn&rsquo;t contain a single railway but a pool of railways. To execute a SQL statement you just need to acquire a free wagon. When the wagon returned from the Database with the SQL response the wagon is put back (into the pool). Now it is usable for another SQL statement. If all wagons are in transit, you need to enlarge the tunnel and add an addition railway (increase pool size).</p><p>Metaphor goes on: Transactions contain multiple SQL commands. Meaning, a transaction is a chain of wagons. Instead of a single wagon a whole train is on the railway. When it arrives at the Database, it gets processed wagon by wagon (SQL statement by statement). If there is a problem with a wagon the previous wagons are discarded and the whole train is sent back (transaction rollback). But if all wagons are processed successfully the train will return all wagons filled with their results (transaction commit). As a transaction is a train of wagons it is always handled on a single railway. That&rsquo;s why SQL transactions are connection bound.</p><h2 id=the-realization class=paragraph-header>the realization <a href=#the-realization></a></h2><p>In practice a connection pool has the following parameter:</p><ul><li><strong><abbr title="Data Source Name">dsn</abbr></strong>: Connection parameter (host, port, user, password, dbname, encryption)</li><li><strong>min_pool_size</strong>: the minimum number of opened, parallel connections in the connection pool (e.g. 5)</li><li><strong>max_pool_size</strong>: the maximum number of opened, parallel connections in the connection pool (e.g. 25)</li></ul><p>It&rsquo;s highly recommendable to set a <em>max_pool_size</em> for safety reasons. Otherwise, accidental long-running SQL statements might block all connection capacities of the database. In this situation the connection pooler will open up more and more connections until the database can&rsquo;t handle anymore. Now the problem is the same as described above. With a <em>max_pool_size</em> set, the application will crash before with an error message like &ldquo;connection pool exhausted&rdquo;.</p><p>A good implementation might work as follows:</p><ol><li>The Server is starting.</li><li>The connection pooler opens the <em>min_pool_size</em> number of connections to the Database.</li><li>When the pooler is done the Server is ready to accept requests.</li><li>When an HTTP request comes in a connection is acquired from the connection pool.</li><li>The SQL statement gets executed.</li><li>Afterwards the connection is put back into the connection pool.</li><li>The HTTP request gets a response.</li></ol><p>Most modern database drivers should include a connection pooling mechanism. Otherwise, there are separate tools like PgBouncer to get the job done.</p><div class=comments>discuss on <a href="https://news.ycombinator.com/item?id=33085854" target=_blank rel="noopener noreferrer"><img src=https://knrdl.github.io/hnlogo.gif alt="Hacker news logo" width=17 height=17>
<span>HackerNews</span>
</a>&nbsp;|
<a href="https://github.com/knrdl/knrdl.github.io/issues/new?title=Explaining+Database+Connection+Pooling" target=_blank rel="noopener noreferrer"><img src=https://knrdl.github.io/github.png alt="Github logo" style=filter:invert(.7) width=17 height=17>
<span>Feedback</span></a></div></article></main><hr><footer>Licensed under <a href=https://creativecommons.org/publicdomain/zero/1.0/ target=_blank rel='noopener norefferer'>CC0 1.0</a> |
<a href=https://gohugo.io target=_blank rel='noopener norefferer'>Hugo</a> theme inspired by <a href=https://github.com/vamc19 target=_blank rel='noopener norefferer'>vamc19</a> |
Hosted by <a href=https://pages.github.com target=_blank rel='noopener norefferer'>Github</a> (<a href=https://github.com/site/privacy target=_blank rel='noopener norefferer'>Privacy Policy</a>)</footer></body></html>