<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on knrdlog</title><link>https://knrdl.github.io/tags/docker/</link><description>Recent content in docker on knrdlog</description><language>en-us</language><copyright>Licensed under &lt;a href='https://creativecommons.org/publicdomain/zero/1.0/' target='_blank' rel='noopener norefferer'>CC0 1.0&lt;/a> |
&lt;a href="https://gohugo.io" target='_blank' rel='noopener norefferer'>Hugo&lt;/a> theme inspired by &lt;a href="https://github.com/vamc19" target='_blank' rel='noopener norefferer'>vamc19&lt;/a> |
Hosted by &lt;a href="https://pages.github.com" target='_blank' rel='noopener norefferer'>Github&lt;/a> (&lt;a href="https://github.com/site/privacy" target='_blank' rel='noopener norefferer'>Privacy Policy&lt;/a>)</copyright><lastBuildDate>Wed, 21 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://knrdl.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Registry Mirror</title><link>https://knrdl.github.io/posts/docker-registry-mirror/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/docker-registry-mirror/</guid><description>&lt;h2 id="concept" class="paragraph-header">Concept &lt;a
href="#concept">&lt;/a>&lt;/h2>
&lt;p>A docker-registry stores docker-images, composed of:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>metadata&lt;/strong>: image names and tags&lt;/li>
&lt;li>&lt;strong>blobs&lt;/strong>: actual image contents&lt;/li>
&lt;/ul>
&lt;p>The most famous public docker-registry is
&lt;a href="https://hub.docker.com" target="_blank" rel="noopener noreferrer">DockerHub&lt;/a>. DockerHub applies a rate-limiting for downloading blobs. The fetching of metadata is not sanctioned. Therefore, a local docker-registry mirror can be used to circumvent DockerHub&amp;rsquo;s rate-limiting. This might also reduce the bandwidth usage of your ISP connection.&lt;/p>
&lt;p>For metadata retrieval the docker-registry mirror will serve as a simple proxy server to the upstream (e.g. DockerHub). If you retrieve a docker-image via the mirror the blobs are stored locally by the mirror. That way the mirror can serve as a cache for further requests. For example, when multiple servers deploy the same docker-image, only the first request will be a cache-miss. As the metadata records are always fetched from upstream, there is no risk of serving outdated docker-images.&lt;/p>
&lt;h2 id="setup" class="paragraph-header">Setup &lt;a
href="#setup">&lt;/a>&lt;/h2>
&lt;h3 id="server" class="paragraph-header">Server &lt;a
href="#server">&lt;/a>&lt;/h3>
&lt;p>The registry mirror is a simple docker container:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">version&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;3.9&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">registry-mirror&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">image&lt;/span>: registry:2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">hostname&lt;/span>: registry-mirror
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">REGISTRY_PROXY_REMOTEURL&lt;/span>: https://registry-1.docker.io &lt;span style="color:#6272a4"># Mirror DockerHub&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">networks&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - reverse_proxy_net &lt;span style="color:#6272a4"># just an example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">deploy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">reservations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">memory&lt;/span>: 16m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">memory&lt;/span>: 250m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It should always be exposed via HTTPS to the clients, by a tls-terminating reverse-proxy. The registry-mirror runs http on port 5000.&lt;/p>
&lt;p>Cached images can be listed via &lt;code>curl https://registry-mirror.example.org/v2/_catalog&lt;/code>.&lt;/p>
&lt;h3 id="clients" class="paragraph-header">Clients &lt;a
href="#clients">&lt;/a>&lt;/h3>
&lt;h4 id="docker" class="paragraph-header">Docker &lt;a
href="#docker">&lt;/a>&lt;/h4>
&lt;blockquote>
&lt;p class="warning">On the server which should execute the registry-mirror run &lt;code>docker pull registry:2&lt;/code> first, to prevent the chicken or egg problem.&lt;/p>
&lt;/blockquote>
&lt;p>To make Docker use the registry mirror, add to &lt;code>/etc/docker/daemon.json&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;registry-mirrors&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;https://registry-mirror.example.org&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then restart the docker daemon: &lt;code>sudo systemctl restart docker.service&lt;/code>&lt;/p>
&lt;h4 id="podman" class="paragraph-header">Podman &lt;a
href="#podman">&lt;/a>&lt;/h4>
&lt;p>Add to &lt;code>$HOME/.config/containers/registries.conf&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[[registry.mirror]]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">location&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;registry-mirror.example.org&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="kaniko" class="paragraph-header">Kaniko &lt;a
href="#kaniko">&lt;/a>&lt;/h4>
&lt;p>To make Kaniko use the mirror, run it with the flag:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>/kaniko/executor --registry-mirror&lt;span style="color:#ff79c6">=&lt;/span>registry-mirror.example.org ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="operations" class="paragraph-header">Operations &lt;a
href="#operations">&lt;/a>&lt;/h2>
&lt;p>The registry mirror might be part of the critical path for high availability. Make sure all hosts are provided with their docker-images before shutting it down for maintenance etc.&lt;/p>
&lt;p>There is no authentication in place, anybody with access can download arbitrary images. Therefore, the registry mirror should only be exposed to the server&amp;rsquo;s network segment.&lt;/p>
&lt;p>There is no storage limit per default and old blobs will not be pruned automatically. An attacker might crash the server by querying too many images. As countermeasure a storage quota should be applied. Also restarting the mirror container from time to time (e.g. patch-day server reboots) helps to reduce the storage usage.&lt;/p></description></item><item><title>Conceptualize Docker Networks to be minimal</title><link>https://knrdl.github.io/posts/minimal-docker-networks/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/minimal-docker-networks/</guid><description>&lt;h2 id="introduction" class="paragraph-header">Introduction &lt;a
href="#introduction">&lt;/a>&lt;/h2>
&lt;p>There are three kinds of private ip ranges:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Class&lt;/th>
&lt;th>CIDR&lt;/th>
&lt;th>Last IP&lt;/th>
&lt;th>IPs&lt;/th>
&lt;th>Typical Usage&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>10.0.0.0/8&lt;/td>
&lt;td>10.255.255.255&lt;/td>
&lt;td>16,777,216&lt;/td>
&lt;td>Big Company Network&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>172.16.0.0/12&lt;/td>
&lt;td>172.31.255.255&lt;/td>
&lt;td>1,048,576&lt;/td>
&lt;td>&lt;em>&lt;strong>Docker Network!&lt;/strong>&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>192.168.0.0/16&lt;/td>
&lt;td>192.168.255.255&lt;/td>
&lt;td>65,536&lt;/td>
&lt;td>Home Network&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>So there are about a million IPs available for docker containers in docker networks. However, docker per default splits them up as /24 CIDRs. Therefore, every docker network can include up to
&lt;math>
&lt;msup>
&lt;mi>2&lt;/mi>
&lt;mrow>
(&lt;mn>32&lt;/mn>&lt;mo>-&lt;/mo>&lt;mn>24&lt;/mn>)
&lt;/mrow>
&lt;/msup>
&lt;mo>-&lt;/mo>
&lt;mn>2&lt;/mn>
&lt;mo>=&lt;/mo>
&lt;mn>254&lt;/mn>
&lt;/math>
Container-IPs. The total number of docker networks is limited to
&lt;math>
&lt;msup>
&lt;mi>2&lt;/mi>
&lt;mrow>
(&lt;mn>24&lt;/mn>&lt;mo>-&lt;/mo>&lt;mn>12&lt;/mn>)
&lt;/mrow>
&lt;/msup>
&lt;mo>=&lt;/mo>
&lt;mn>4096&lt;/mn>
&lt;/math>.&lt;/p>
&lt;p>While these defaults are okay, it&amp;rsquo;s possible to run out of address spaces, &lt;strong>especially if private Class B addresses are used elsewhere&lt;/strong> (by other applications/routing). Using more docker networks with fewer containers per network has two benefits: Security and Safety.&lt;/p>
&lt;h2 id="security--safety" class="paragraph-header">Security &amp;amp; Safety &lt;a
href="#security--safety">&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Scenario with three containers: gateway, appserver, database.&lt;/p>
&lt;p>It&amp;rsquo;s easy to put all three of them in a single docker network. But this would allow the gateway to access the database, which is not required. Therefore, 2 docker networks should be utilized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scenario with three containers: gateway, appserver1, appserver2.&lt;/p>
&lt;p>Using a single network to connect the appservers to the gateway, allows appserver1 to talk to appserver2. This might not be desired, if app1 and app2 are two distinct applications.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>The security gain is a better separation of trust levels, following the principle of least privilege. Anyway, an advanced attacker can still try OSI-Layer 2 (&amp;ldquo;MAC-Level&amp;rdquo;) sniffing attacks.&lt;/p>
&lt;p>The bigger gain is the safety of the container environment. The impact of configuration mistakes is limited. The architecture is clearer: Confusion about what service the hostname &amp;ldquo;app&amp;rdquo; belongs to is hopefully prevented.&lt;/p>
&lt;p>The cost of this approach is that there might be more docker networks needed than the 4096 possible ones. A config change allows to create more networks.&lt;/p>
&lt;blockquote>
&lt;p class="info">This is just an example! 4096 is a reasonable amount of networks. But if there is only a subspace of private class B addresses available or class C must be used, then things might look different. Per default max 256 docker networks can be produced in class C, which could be limiting.&lt;/p>
&lt;/blockquote>
&lt;h2 id="configuration" class="paragraph-header">Configuration &lt;a
href="#configuration">&lt;/a>&lt;/h2>
&lt;p>In &lt;code>/etc/docker/daemon.json&lt;/code> add:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;default-address-pools&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;base&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;172.16.0.0/12&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#bd93f9">27&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will use the complete Class B private namespace (&lt;code>172.16.0.0/12&lt;/code>). The CIDR per docker network is /27.&lt;/p>
&lt;p>Max docker networks per host:
&lt;math>
&lt;msup>
&lt;mi>2&lt;/mi>
&lt;mrow>
(&lt;mn>27&lt;/mn>&lt;mo>-&lt;/mo>&lt;mn>12&lt;/mn>)
&lt;/mrow>
&lt;/msup>
&lt;mo>=&lt;/mo>
&lt;mn>32,768&lt;/mn>
&lt;/math>&lt;/p>
&lt;p>Max containers per docker network:
&lt;math>
&lt;msup>
&lt;mi>2&lt;/mi>
&lt;mrow>
(&lt;mn>32&lt;/mn>&lt;mo>-&lt;/mo>&lt;mn>27&lt;/mn>)
&lt;/mrow>
&lt;/msup>
&lt;mo>-&lt;/mo>
&lt;mn>2&lt;/mn>
&lt;mo>=&lt;/mo>
&lt;mn>30&lt;/mn>
&lt;/math>&lt;/p></description></item><item><title>Strategies for Docker image tagging</title><link>https://knrdl.github.io/posts/docker-image-tagging/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/docker-image-tagging/</guid><description>&lt;p>Each docker image has a URI-style name like &lt;code>domain.tld:port/directory/subdir:tag&lt;/code>. The image name &lt;code>ubuntu&lt;/code> is just a shortcut for &lt;code>docker.io/library/ubuntu:latest&lt;/code>. The default tag (if omitted) is &lt;code>latest&lt;/code>. Docker (or &lt;abbr title="Open Container Initiative">OCI&lt;/abbr>) images should be built automatically in &lt;abbr title="Continuous Integration">CI&lt;/abbr>-Pipelines. There are multiple strategies for tagging those images:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Docker Image Tagging via Git Commit Tags:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Relevant git commits are tagged as versions, e.g. &lt;code>v3.2.1&lt;/code>&lt;/li>
&lt;li>The corresponding docker image gets tagged as &lt;code>3.2.1&lt;/code>. If there are multiple image flavours, maybe also &lt;code>3.2.1-alpine&lt;/code> or &lt;code>v3.2.1-slim&lt;/code>&lt;/li>
&lt;li>
&lt;a href="https://semver.org/" target="_blank" rel="noopener noreferrer">Semantic Versioning&lt;/a> is also applicable: In addition to the image tag &lt;code>3.2.1&lt;/code>, the tags &lt;code>3.2&lt;/code> and &lt;code>3&lt;/code> should also be assigned, if &lt;code>3.2.1&lt;/code> is the newest version for both version series.&lt;/li>
&lt;li>The image created from the newest git commit tag (the newest version) must also be tagged as &lt;code>latest&lt;/code>&lt;/li>
&lt;li>Docker images without associated git commit tag can be tagged as &lt;code>edge&lt;/code> (convention) or something like &lt;code>unstable&lt;/code>, &lt;code>nightly&lt;/code> etc.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Docker Image Tagging via Git Commit Hash:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>If there are no distinguishable software versions, the first 6 letters of the git commit hash (SHA) can be used to tag an image.&lt;/li>
&lt;li>The &lt;code>latest&lt;/code> tag gets assigned manually to a docker image.&lt;/li>
&lt;li>Pro: It&amp;rsquo;s easy to find the belonging image for a git commit. So an old version can easily be deployed if the newer one fails. Therefore, you must know which commit introduced the problem.&lt;/li>
&lt;li>Contra:
&lt;ul>
&lt;li>Produces many tagged images =&amp;gt; Docker Image Tag Deletion Policy must be enforced&lt;/li>
&lt;li>Tags will only be sortable by their creation date (might be wrong in case of manual intervention)&lt;/li>
&lt;li>It&amp;rsquo;s hard to know which tags bring in small or big changes (missing
&lt;a href="https://semver.org/" target="_blank" rel="noopener noreferrer">semantic versioning&lt;/a>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Strategy is only useful if there is no software versioning scheme in place and also git push&amp;rsquo;s to the main branch are not too frequent.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Docker Image Tagging for the Bleeding Edge:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>There is not dedicated tagging at all&lt;/li>
&lt;li>The newest commit gets tagged as &lt;code>latest&lt;/code>&lt;/li>
&lt;li>Move fast and break things&lt;/li>
&lt;li>To reproduce old versions the old image must be built again (make sure to pin the versions of all dependencies your software needs). Alternatively important old versions can be tagged manually.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Docker Image Tagging with Timestamps:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Each docker image tag is a timestamp of the build date.&lt;/li>
&lt;li>The last run build is tagged as &lt;code>latest&lt;/code>&lt;/li>
&lt;li>Problematic if old versions are built via CI-Pipelines at a later time&lt;/li>
&lt;li>Useful for nightly builds only. Produce tags like &lt;code>nightly-YYYYMMDD&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>Which strategy is right for me? It depends! Maybe a combination &amp;hellip;&lt;/p>
&lt;hr>
&lt;h3 id="tldr--opinion" class="paragraph-header">TL;DR / Opinion &lt;a
href="#tldr--opinion">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Use git tags for software versioning&lt;/strong>
&lt;ul>
&lt;li>If the newest git tag is &lt;code>v3.2.1&lt;/code>, the built docker image should be tagged as &lt;code>3.2.1&lt;/code>, &lt;code>3.2&lt;/code> and &lt;code>3&lt;/code>.&lt;/li>
&lt;li>The newest software version (by git tag) additionally gets tagged as &lt;code>latest&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Building a docker image from a git commit without tag, the resulting docker image should be tagged as &lt;code>edge&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Bind non-root process to privileged port inside a Docker container</title><link>https://knrdl.github.io/posts/docker-non-root-privileged-port/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/docker-non-root-privileged-port/</guid><description>&lt;p>The Principle of Least Privilege (PoLP) should also be applied to applications inside a container! Running stuff as root
user is never a good idea. A custom user profile with fewer privileges should be created and used instead.&lt;/p>
&lt;p>But such a user cannot bind a privileged port (&amp;lt;1024), e.g. start a webserver on port 80. Exposure via port binding to
the host is still unproblematic, e.g. &lt;code>docker run -p 80:8080 ...&lt;/code> will bind port 8080 of the container to port 80 on the
host.&lt;/p>
&lt;p>But what if two services share a Docker Network to reach each other? Then requests have to be made to
e.g. &lt;strong>http://service2:8080/api&lt;/strong> (includes the port 8080). This is a bit ugly because &lt;strong>service1&lt;/strong> now needs to contain
runtime information about &lt;strong>service2&lt;/strong> (contradicts goal of loose coupling). An endpoint like &lt;strong>http://service2/api&lt;/strong> (defaults to port 80) is preferable.&lt;/p>
&lt;p>The following Dockerfile achieves that goal:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">FROM&lt;/span>&lt;span style="color:#f1fa8c"> python:3-alpine&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># allow non privileged user to run server on port 80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">RUN&lt;/span> apk add --no-cache libcap &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> setcap &lt;span style="color:#f1fa8c">&amp;#39;cap_net_bind_service=+ep&amp;#39;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>readlink -f &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>which python3&lt;span style="color:#ff79c6">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> apk del libcap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">EXPOSE&lt;/span>&lt;span style="color:#f1fa8c"> 80/tcp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">RUN&lt;/span> adduser --home /home/appname --disabled-password --shell /bin/false --uid &lt;span style="color:#bd93f9">1000&lt;/span> appname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># all commands after the USER-command will be executed as user `appname`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">USER&lt;/span>&lt;span style="color:#f1fa8c"> appname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">RUN&lt;/span> whoami
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># now the app can run on port 80 as non root user&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">CMD&lt;/span> python3 myapp.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The program &lt;code>setcap&lt;/code> is used to give the executable (e.g. &lt;code>/usr/bin/python3&lt;/code> or &lt;code>/bin/myapp&lt;/code>) the necessary capability (permission). It&amp;rsquo;s not needed afterwards, so it might be deleted to keep the image small.&lt;/p>
&lt;blockquote>
&lt;p class="info">If you work with &lt;abbr title="Advanced Packaging Tool">APT&lt;/abbr> (Ubuntu/Debian images) just use the
package &lt;code>libcap2-bin&lt;/code> instead of &lt;code>libcap&lt;/code>.&lt;/p>
&lt;/blockquote></description></item><item><title>Rootless Docker as a Service</title><link>https://knrdl.github.io/posts/rootless-docker-as-a-service/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/rootless-docker-as-a-service/</guid><description>&lt;p>Sometimes access to a docker daemon on a remote host is needed, e.g. a developer without docker on local machine or a
CI/CD pipeline to test docker image runtime behaviour.&lt;/p>
&lt;h2 id="exposing-the-docker-socket-of-the-remote-host" class="paragraph-header">Exposing the docker socket of the remote host &lt;a
href="#exposing-the-docker-socket-of-the-remote-host">&lt;/a>&lt;/h2>
&lt;p>This could be done via TCP directly by docker, or indirectly via tcp socket to unix socket redirect:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>socat TODO
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The lack of authentication means everybody on the network can get trivially root access on the host (via starting a
docker container). As a countermeasure the tcp socket can be tunneled via e.g. SSH:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># server:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>socat TODO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># client:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssh TODO
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But this still means giving the client full root access to the host&lt;/p>
&lt;h2 id="rootless-docker-in-a-docker-container" class="paragraph-header">Rootless Docker in a Docker container &lt;a
href="#rootless-docker-in-a-docker-container">&lt;/a>&lt;/h2>
&lt;p>Docker in Docker (DinD) is nothing new. But since v19.03 docker supports rootless mode (stable in
v20.10). So an unprivileged container can be started&lt;/p>
&lt;p>todo: problem container außen ist immernoch priviligiert&lt;/p></description></item><item><title>Docker Swarm: `error creating vxlan interface: file exists`</title><link>https://knrdl.github.io/posts/docker-swarm-error-create-vxlan/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/docker-swarm-error-create-vxlan/</guid><description>&lt;p>If docker swarm rejects to deploy a service because network interface already exists:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ docker service ps stackname_appname --no-trunc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rejected &lt;span style="color:#bd93f9">34&lt;/span> seconds ago &lt;span style="color:#f1fa8c">&amp;#34;network sandbox join failed: subnet sandbox join failed for &amp;#34;&lt;/span>10.0.14.0/24&lt;span style="color:#f1fa8c">&amp;#34;: error creating vxlan interface: file exists
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then find all problematic interfaces on the host and delete them:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ip -d link show | grep vx | grep DOWN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo ip link delete vx-001095-owhr8 &lt;span style="color:#6272a4"># for each entry&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now redeploying should work!&lt;/p></description></item><item><title>Svelte without node.js installation</title><link>https://knrdl.github.io/posts/svelte-without-node-installation/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/svelte-without-node-installation/</guid><description>&lt;p>Docker (or podman) to the rescue!&lt;/p>
&lt;h2 id="setup-project" class="paragraph-header">Setup project &lt;a
href="#setup-project">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run -it --rm --user &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$UID&lt;/span>&lt;span style="color:#f1fa8c">:&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$UID&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> -v &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PWD&lt;/span>&lt;span style="color:#f1fa8c">:&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PWD&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> -w &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PWD&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> node:alpine npm init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="development" class="paragraph-header">Development &lt;a
href="#development">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run -it --rm --user &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$UID&lt;/span>&lt;span style="color:#f1fa8c">:&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$UID&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> -v &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PWD&lt;/span>&lt;span style="color:#f1fa8c">:&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PWD&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> -w &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PWD&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> -p8080:8080 -p35729:35729 --env &lt;span style="color:#8be9fd;font-style:italic">HOST&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>0.0.0.0 node:alpine npm run dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Open
&lt;a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">localhost:8080&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p class="info">Port 35729 is live reload websocket (optional)&lt;/p>
&lt;/blockquote>
&lt;h2 id="custom-bashrc-shortcut" class="paragraph-header">Custom &lt;code>.bashrc&lt;/code> shortcut &lt;a
href="#custom-bashrc-shortcut">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">alias&lt;/span> svelte-npm&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;sudo docker run -it --rm --user &amp;#34;$UID:$UID&amp;#34; -v &amp;#34;$PWD:$PWD&amp;#34; -w &amp;#34;$PWD&amp;#34; -p8080:8080 -p35729:35729 --env HOST=0.0.0.0 node:alpine npm&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Usage: &lt;code>$ svelte-npm run dev&lt;/code>&lt;/p>
&lt;h3 id="more-general-approach" class="paragraph-header">More general approach &lt;a
href="#more-general-approach">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">alias&lt;/span> docker-dir&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;sudo docker run -it --rm --user &amp;#34;$UID:$UID&amp;#34; -v &amp;#34;$PWD:$PWD&amp;#34; -w &amp;#34;$PWD&amp;#34; --env HOST=0.0.0.0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>todo: podman&lt;/p></description></item><item><title>Fix gitlab immense disk usage</title><link>https://knrdl.github.io/posts/gitlab-immense-disk-usage/</link><pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/gitlab-immense-disk-usage/</guid><description>&lt;p>The gitlab docker registry has no cleanup job per default. If an image tag gets overwritten (updated) then the original
image layer blobs will be kept as orphans. To clean those up run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>gitlab-ctl registry-garbage-collect --delete-untagged --delete-manifest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="automation" class="paragraph-header">Automation &lt;a
href="#automation">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>run the command via Cron (the gitlab image contains &lt;code>go-crond&lt;/code>)&lt;/li>
&lt;li>set command in env var &lt;code>GITLAB_POST_RECONFIGURE_SCRIPT&lt;/code> (executed at least on each container start)&lt;/li>
&lt;/ul>
&lt;h2 id="conclusion" class="paragraph-header">Conclusion &lt;a
href="#conclusion">&lt;/a>&lt;/h2>
&lt;p>170GiB server disk storage freed&lt;/p></description></item></channel></rss>