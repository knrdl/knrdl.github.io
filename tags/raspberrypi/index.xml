<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raspberrypi on knrdlog</title><link>https://knrdl.github.io/tags/raspberrypi/</link><description>Recent content in Raspberrypi on knrdlog</description><language>en-us</language><copyright>Licensed under &lt;a href='https://creativecommons.org/publicdomain/zero/1.0/' target='_blank' rel='noopener norefferer'>CC0 1.0&lt;/a> |
&lt;a href="https://gohugo.io" target='_blank' rel='noopener norefferer'>Hugo&lt;/a> theme inspired by &lt;a href="https://github.com/vamc19" target='_blank' rel='noopener norefferer'>vamc19&lt;/a> |
Hosted by &lt;a href="https://pages.github.com" target='_blank' rel='noopener norefferer'>Github&lt;/a> (&lt;a href="https://github.com/site/privacy" target='_blank' rel='noopener norefferer'>Privacy Policy&lt;/a>)</copyright><lastBuildDate>Mon, 03 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://knrdl.github.io/tags/raspberrypi/index.xml" rel="self" type="application/rss+xml"/><item><title>How to stop your Raspberry Pi from eating SD Cards</title><link>https://knrdl.github.io/posts/raspberrypi-eating-sd-cards/</link><pubDate>Mon, 03 Oct 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/raspberrypi-eating-sd-cards/</guid><description>&lt;h2 id="problem" class="paragraph-header">Problem &lt;a
href="#problem">&lt;/a>&lt;/h2>
&lt;p>SD (or MicroSD) Cards are cheap flash storage. Their lifetime is limited by the performable write operations. If their end of life is reached, they don&amp;rsquo;t work at all or read data unreliably.&lt;/p>
&lt;p>A Raspberry Pi produces more IO operations than a typical digital camera (which SD Cards are conceptualized for). The load is mostly produced by writing:&lt;/p>
&lt;ul>
&lt;li>Temporary files in &lt;code>/tmp/&lt;/code>&lt;/li>
&lt;li>Variable files in &lt;code>/var/&lt;/code>&lt;/li>
&lt;li>The swap file in &lt;code>/var/swap&lt;/code>&lt;/li>
&lt;li>Files in other application and user specific directories&lt;/li>
&lt;/ul>
&lt;p>It also depends on the usage of the Pi: e.g. compiling a big pile of software on the Pi is never a good idea in terms of SD Card lifetime.&lt;/p>
&lt;p>It&amp;rsquo;s possible to run a Pi only with a SD Card for a long time. One of my Pi&amp;rsquo;s now runs successfully for more than 5 years that way. However, you can&amp;rsquo;t tell it beforehand.&lt;/p>
&lt;h2 id="solution" class="paragraph-header">Solution &lt;a
href="#solution">&lt;/a>&lt;/h2>
&lt;p>So the solution is to reduce the IO operations performed against the SD Card. A simple attempt is to disable swapping: &lt;code>sudo systemctl disable --now dphys-swapfile&lt;/code>. A better alternative is moving write intense directories to an external drive. There are two options:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Option A&lt;/strong>: The Raspberry boots directly from a USB drive (e.g. USB thumb drive, SSD or HDD). No SD Card required.&lt;/li>
&lt;li>&lt;strong>Option B&lt;/strong>: The Raspberry boots from the SD Card and mounts an external USB drive where the heavy disk IO is performed later on.&lt;/li>
&lt;/ul>
&lt;h3 id="option-a---fresh-installation" class="paragraph-header">Option A - Fresh installation &lt;a
href="#option-a---fresh-installation">&lt;/a>&lt;/h3>
&lt;p>This option is pretty easy to realize, just flash the OS image (e.g. Raspberry Pi OS, formerly known as Raspbian) to the USB drive. However, it might not work with all kinds of USB drives. Also, a cheap USB thumb drive might have the same problems as a SD Card. Therefore, a durable SSD should be used instead. An old HDD is also a valid alternative. But your Pi might crash if spinning up the HDD consumes more power than can be supplied.&lt;/p>
&lt;h3 id="option-b---external-disk" class="paragraph-header">Option B - External disk &lt;a
href="#option-b---external-disk">&lt;/a>&lt;/h3>
&lt;p>This is useful if your Pi is already set up and running. The separation will split the filestorage into static files (stored on the SD Card) and dynamic files (stored on the USB drive).&lt;/p>
&lt;p>You need to copy the dynamic files to the external drive. But first you should stop all running applications to prevent inconsistency when copying files.&lt;/p>
&lt;p>Disable the swap:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo swapoff -a &lt;span style="color:#6272a4"># disable the swap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /proc/swaps &lt;span style="color:#6272a4"># check that no swap is active&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mount the external usb drive. In the example it has the Label &amp;ldquo;usb0&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ls /dev/disk/by-label/usb0 &lt;span style="color:#6272a4"># check the device file exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mkdir -p /media/usb0 &lt;span style="color:#6272a4"># create the mountpoint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mount -o defaults /dev/disk/by-label/usb0 /media/usb0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Copy all directories with dynamic data (at least &lt;code>/tmp&lt;/code> and &lt;code>/var&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo cp -ar /tmp/ /media/usb0/tmp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo cp -ar /var/ /media/usb0/var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p class="info">It&amp;rsquo;s optional to copy &lt;code>/tmp&lt;/code> as it only contains ephemeral data. But the directory must exist and have the correct permissions set!&lt;/p>
&lt;/blockquote>
&lt;p>Add to &lt;code>/etc/fstab&lt;/code> the new mount records:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>/dev/disk/by-label/usb0 /media/usb0 ext4 defaults 0 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/media/usb0/var /var none bind 0 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/media/usb0/tmp /tmp none bind 0 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The external drive will be mounted to &lt;code>/media/usb0&lt;/code>. The directories &lt;code>/tmp&lt;/code> and &lt;code>/var&lt;/code> (dynamic data) will be pointed to the corresponding directories on the external device.&lt;/p>
&lt;blockquote>
&lt;p class="warning">The external drive is mounted with option &lt;code>defaults&lt;/code>. If the disk is not connected or cannot be read, the raspi will not boot! As a countermeasure the options &lt;code>defaults,nofail&lt;/code> could be used. But then the data will be written to the SD card in case of a disk failure. Inconsistent data would be the result.&lt;/p>
&lt;/blockquote>
&lt;p>Now reboot the Pi: &lt;code>sudo reboot&lt;/code>.&lt;/p>
&lt;p>Check that everything is working:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>touch /tmp/fs.test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls /media/usb0/fs/tmp/fs.test &lt;span style="color:#6272a4"># should output the filepath&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the swap is not reactivated yet, run &lt;code>sudo swapon /var/swap&lt;/code>.&lt;/p></description></item></channel></rss>