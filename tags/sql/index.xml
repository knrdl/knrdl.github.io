<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sql on knrdlog</title><link>https://knrdl.github.io/tags/sql/</link><description>Recent content in Sql on knrdlog</description><language>en-us</language><copyright>Licensed under &lt;a href='https://creativecommons.org/publicdomain/zero/1.0/' target='_blank' rel='noopener norefferer'&gt;CC0 1.0&lt;/a&gt; |
&lt;a href="https://gohugo.io" target='_blank' rel='noopener norefferer'&gt;Hugo&lt;/a&gt; theme inspired by &lt;a href="https://github.com/vamc19" target='_blank' rel='noopener norefferer'&gt;vamc19&lt;/a&gt; |
Hosted by &lt;a href="https://pages.github.com" target='_blank' rel='noopener norefferer'&gt;Github&lt;/a&gt; (&lt;a href="https://github.com/site/privacy" target='_blank' rel='noopener norefferer'&gt;Privacy Policy&lt;/a&gt;)</copyright><lastBuildDate>Fri, 28 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://knrdl.github.io/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>Postgres: Fast row count estimates</title><link>https://knrdl.github.io/posts/postgres-fast-row-count/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/postgres-fast-row-count/</guid><description>&lt;p&gt;Counting rows in postgresql is as easy as &lt;code&gt;select count(1) from mytable&lt;/code&gt;. This is a precise count. But it becomes slow on an increasing number of records, especially when a sequential scan of all table records is required, see &lt;code&gt;explain select count(1) from mytable&lt;/code&gt;. But in the end the user often doesn&amp;rsquo;t care if there are about 125_000_000 or exactly 124_756_849 results. Therefore, a fast row count estimate might be more desirable than a slow precise count.&lt;/p&gt;
&lt;p&gt;Postgres runs internal statistics for the query planner to produce performant decisions. These statistics also include estimates of row counts. They are updated regularly by autovacuum or manually by &lt;code&gt;analyze mytable&lt;/code&gt;. The later one is only necessary to get better results on very recent insert/delete batches.&lt;/p&gt;
&lt;p&gt;This snippet uses the postgres statistics to estimate the row count:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python3" data-lang="python3"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;import&lt;/span&gt; psycopg2
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;conn &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; psycopg2&lt;span style="color:#ff79c6"&gt;.&lt;/span&gt;connect(os&lt;span style="color:#ff79c6"&gt;.&lt;/span&gt;getenv(&lt;span style="color:#f1fa8c"&gt;&amp;#39;DB_DSN&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cur &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; conn&lt;span style="color:#ff79c6"&gt;.&lt;/span&gt;cursor()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cur&lt;span style="color:#ff79c6"&gt;.&lt;/span&gt;execute(&lt;span style="color:#f1fa8c"&gt;&amp;#39;explain (format json) select * from mytable;&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;res &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; cur&lt;span style="color:#ff79c6"&gt;.&lt;/span&gt;fetchone()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;row_count &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; res[&lt;span style="color:#bd93f9"&gt;0&lt;/span&gt;][&lt;span style="color:#bd93f9"&gt;0&lt;/span&gt;][&lt;span style="color:#f1fa8c"&gt;&amp;#39;Plan&amp;#39;&lt;/span&gt;][&lt;span style="color:#f1fa8c"&gt;&amp;#39;Plan Rows&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>Miniflux Housekeeping</title><link>https://knrdl.github.io/posts/miniflux-housekeeping/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/miniflux-housekeeping/</guid><description>&lt;p&gt;
&lt;a href="https://miniflux.app/" target="_blank" rel="noopener noreferrer"&gt;Miniflux&lt;/a&gt; is a feed reader. As adding feeds is easy, some bloat will appear.&lt;/p&gt;
&lt;h3 id="article-age" class="paragraph-header"&gt;Article Age &lt;a
href="#article-age"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;List the top 10 feeds with the oldest articles. No updates, no need to keep a subscription.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; f.feed_url, f.title,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;max&lt;/span&gt;(published_at) &lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;public&lt;/span&gt;.entries &lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; feed_id &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; f.id) last_published_at
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; feeds f &lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; f.user_id &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; (&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; id &lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; users &lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; username &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; &lt;span style="color:#f1fa8c"&gt;&amp;#39;knrdl&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;order&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;by&lt;/span&gt; last_published_at &lt;span style="color:#ff79c6"&gt;limit&lt;/span&gt; &lt;span style="color:#bd93f9"&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="article-count" class="paragraph-header"&gt;Article Count &lt;a
href="#article-count"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;List the top 10 feeds with the fewest articles. An article count of 0 either means that the feed never produced articles since you subscribed to it. But it can also mean that the articles have been removed from the source after you read them (Miniflux marks old read articles as removed in the DB and deletes them if they disappear from the source).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; f.feed_url, f.title,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;count&lt;/span&gt;(&lt;span style="color:#ff79c6"&gt;*&lt;/span&gt;) &lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;public&lt;/span&gt;.entries &lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; feed_id &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; f.id) article_count
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; feeds f &lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; f.user_id &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; (&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; id &lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; users &lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; username &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; &lt;span style="color:#f1fa8c"&gt;&amp;#39;knrdl&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;order&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;by&lt;/span&gt; article_count &lt;span style="color:#ff79c6"&gt;limit&lt;/span&gt; &lt;span style="color:#bd93f9"&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>Explaining Database Connection Pooling</title><link>https://knrdl.github.io/posts/db-connection-pooling/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/db-connection-pooling/</guid><description>&lt;h2 id="the-problem" class="paragraph-header"&gt;the problem &lt;a
href="#the-problem"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Connection Pooling is an often overlooked concept when it comes to databases. An inexperienced developer might implement an API backend like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP Request comes in&lt;/li&gt;
&lt;li&gt;Open connection to the database&lt;/li&gt;
&lt;li&gt;Execute SQL command and read response&lt;/li&gt;
&lt;li&gt;Close connection to the database (also often forgotten)&lt;/li&gt;
&lt;li&gt;Send HTTP response&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Opening and closing a connection (step 2 &amp;amp; 4) produces load on the database server instance. Beside the number of parallel open connections is limited. That way forgetting to close connections might even make the database unavailable in the long run. Connection pooling solves these issues by keeping a sufficient number of durable connections to the database open.&lt;/p&gt;
&lt;h2 id="the-metaphor" class="paragraph-header"&gt;the metaphor &lt;a
href="#the-metaphor"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;figure&gt;
&lt;img src="metaphor.png" alt="metaphor visualization" style="max-height: 375px;"&gt;
&lt;/figure&gt;
&lt;p&gt;Metaphor: Between Server and Database exists a tunnel, called network link. In the tunnel is a single track of rails, known as connection. As said, reusing the rails is easier than building new ones everytime. The track of rails carries a single wagon. The wagon transports a SQL command from the Server to the Database and returns the execution result (e.g. selected rows) back. If the wagon is in transit the railway is blocked. No other wagon can use the railway at the same time. Therefore, the tunnel doesn&amp;rsquo;t contain a single railway but a pool of railways. To execute a SQL statement you just need to acquire a free wagon. When the wagon returned from the Database with the SQL response the wagon is put back (into the pool). Now it is usable for another SQL statement. If all wagons are in transit, you need to enlarge the tunnel and add an addition railway (increase pool size).&lt;/p&gt;
&lt;p&gt;Metaphor goes on: Transactions contain multiple SQL commands. Meaning, a transaction is a chain of wagons. Instead of a single wagon a whole train is on the railway. When it arrives at the Database, it gets processed wagon by wagon (SQL statement by statement). If there is a problem with a wagon the previous wagons are discarded and the whole train is sent back (transaction rollback). But if all wagons are processed successfully the train will return all wagons filled with their results (transaction commit). As a transaction is a train of wagons it is always handled on a single railway. That&amp;rsquo;s why SQL transactions are connection bound.&lt;/p&gt;
&lt;h2 id="the-realization" class="paragraph-header"&gt;the realization &lt;a
href="#the-realization"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In practice a connection pool has the following parameter:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;abbr title="Data Source Name"&gt;dsn&lt;/abbr&gt;&lt;/strong&gt;: Connection parameter (host, port, user, password, dbname, encryption)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_pool_size&lt;/strong&gt;: the minimum number of opened, parallel connections in the connection pool (e.g. 5)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_pool_size&lt;/strong&gt;: the maximum number of opened, parallel connections in the connection pool (e.g. 25)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&amp;rsquo;s highly recommendable to set a &lt;em&gt;max_pool_size&lt;/em&gt; for safety reasons. Otherwise, accidental long-running SQL statements might block all connection capacities of the database. In this situation the connection pooler will open up more and more connections until the database can&amp;rsquo;t handle anymore. Now the problem is the same as described above. With a &lt;em&gt;max_pool_size&lt;/em&gt; set, the application will crash before with an error message like &amp;ldquo;connection pool exhausted&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;A good implementation might work as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Server is starting.&lt;/li&gt;
&lt;li&gt;The connection pooler opens the &lt;em&gt;min_pool_size&lt;/em&gt; number of connections to the Database.&lt;/li&gt;
&lt;li&gt;When the pooler is done the Server is ready to accept requests.&lt;/li&gt;
&lt;li&gt;When an HTTP request comes in a connection is acquired from the connection pool.&lt;/li&gt;
&lt;li&gt;The SQL statement gets executed.&lt;/li&gt;
&lt;li&gt;Afterwards the connection is put back into the connection pool.&lt;/li&gt;
&lt;li&gt;The HTTP request gets a response.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Most modern database drivers should include a connection pooling mechanism. Otherwise, there are separate tools like PgBouncer to get the job done.&lt;/p&gt;</description></item><item><title>Postgres: Create enum if not exists</title><link>https://knrdl.github.io/posts/postgres-enum/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/postgres-enum/</guid><description>&lt;p&gt;In postgres there is nothing like &lt;code&gt;create table if not exists&lt;/code&gt; for enums. Workaround:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;DO&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$$
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#ff79c6"&gt;BEGIN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#ff79c6"&gt;CREATE&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;TYPE&lt;/span&gt; request_type &lt;span style="color:#ff79c6"&gt;AS&lt;/span&gt; ENUM (&lt;span style="color:#f1fa8c"&gt;&amp;#39;request_type1&amp;#39;&lt;/span&gt;, &lt;span style="color:#f1fa8c"&gt;&amp;#39;request_type2&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#ff79c6"&gt;EXCEPTION&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#ff79c6"&gt;WHEN&lt;/span&gt; duplicate_object &lt;span style="color:#ff79c6"&gt;THEN&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#ff79c6"&gt;END&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$$;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>Cleanup bloated postgres index</title><link>https://knrdl.github.io/posts/postgres-bloated-index/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://knrdl.github.io/posts/postgres-bloated-index/</guid><description>&lt;h2 id="1-find-db-byte-sizes" class="paragraph-header"&gt;1. find db byte sizes &lt;a
href="#1-find-db-byte-sizes"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;SELECT&lt;/span&gt; datname, pg_size_pretty(pg_database_size(datname))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;FROM&lt;/span&gt; pg_database
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;ORDER&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;by&lt;/span&gt; pg_database_size(datname) &lt;span style="color:#ff79c6"&gt;DESC&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="2-find-tables--indices-sizes" class="paragraph-header"&gt;2. find tables + indices sizes &lt;a
href="#2-find-tables--indices-sizes"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;select&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;table_name&lt;/span&gt;, pg_size_pretty(pg_total_relation_size(quote_ident(&lt;span style="color:#ff79c6"&gt;table_name&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;from&lt;/span&gt; information_schema.tables
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;where&lt;/span&gt; table_schema &lt;span style="color:#ff79c6"&gt;=&lt;/span&gt; &lt;span style="color:#f1fa8c"&gt;&amp;#39;public&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;order&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;by&lt;/span&gt; pg_total_relation_size(quote_ident(&lt;span style="color:#ff79c6"&gt;table_name&lt;/span&gt;)) &lt;span style="color:#ff79c6"&gt;desc&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="3-recreate-index" class="paragraph-header"&gt;3. recreate index &lt;a
href="#3-recreate-index"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff79c6"&gt;REINDEX&lt;/span&gt; &lt;span style="color:#ff79c6"&gt;TABLE&lt;/span&gt; hungry;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="conclusion" class="paragraph-header"&gt;Conclusion &lt;a
href="#conclusion"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;index shrank from ~12GiB to ~800MiB&lt;/p&gt;</description></item></channel></rss>